Clojure 拥有动态语言的所有好处。这意味着你可以在程序被加载后依然可以改变它，并且不用采取额外的步骤去编译代码。
你既不用停止也不用重启正在运行的应用就可以让修改生效。
这对于其他语言来说可是一个非常显著的优势，特别是如果你正打算将变化动态地（不用停止和重启服务器）呈献给用户时。
要想改变一个已经加载的程序，你唯一需要的是使用REPL去加载变化的地方。
REPL是一个独立的程序，Clojure利用它提供给你和它的编译器直接交互的功能，当然也能与已经加载的程序进行交互。
REPL代表读取（Read）、求值（Evaluate）、打印（Print）和 循环（Loop）。为了使用REPL，你只需要使用操作系统提供的命令行来运行它。

表达式求值
打开你的REPL，随机敲入一些字符。很大几率上Clojure会及时地作出相应一个错误。它可不是什么值都会接受。
user=> ugh
CompilerException java.lang.RuntimeException: Unable to resolve symbol: ugh in this context, compiling:(NO_SOURCE_PATH:0:0)

实际上你会发现Clojure只能对符合语法规则的表达式求值。
有一点需要记住，所有的表达式都会返回值。即使这个表达式什么也不做，它也会返回值，哪怕仅仅是一个'nil'(类似java中的null)。
user=> (do)  //先不用管do是做什么的，其实什么也不做
nil
这是一个很好的特性，因为如果clojure要是什么都不返回的话，你不知道它是否已经执行完毕还是陷入了死循环。

求字面值
我们之前求值都是针对“表达式”（expression）。我们为什么不用“代码”(code)或者“声明”(statements)来代替“表达式”这个词呢？
一个理由是“表达式”这个词本身就包含了“代码"或者”声明”这两个概念。
拎一个重要的原因是clojure可不止是只能对代码求值。clojure可以对“数据”（data）求值，这一点与其他语言不同。
对clojure来说，代码即数据。(感觉这个例子体现的不是太明显)

数据被求值时仅仅返回自身
user=> 21.42
21.42
user=> "a string of characters"
"a string of characters"

Clojure的数据操作可不仅仅是字符串或者数字，实际上它支持一套非常丰富的数据类型和数据结构。但是在我们深入clojure之前，还是得先对着门语言多一些了解。
